/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.1.6.0 (NJsonSchema v10.0.28.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { map } from 'rxjs/operators';
import { Observable } from 'rxjs';
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';

import { isMoment } from 'moment';
import * as moment from 'moment';
import * as qs from 'qs';
import { Constants } from 'src/app/constants';

export function buildQueryString(queryParams: any): string {
    const params = Object.entries(queryParams || {}).reduce((params: any, [key, value]) => {
        params[key] = convertQueryParam(value);
        return params;
    }, {});

    return qs.stringify(params, { addQueryPrefix: true, allowDots: true });
}

function convertQueryParam(queryParam: any): any {
    if (isMoment(queryParam)) {
        return queryParam.toISOString();
    } else if (Array.isArray(queryParam)) {
        const v = queryParam.map(convertQueryParam);
        return v;
    } else if (typeof queryParam === 'object' && queryParam != null) {
        return Object.entries(queryParam).reduce((queryParam: any, [key, value]) => {
            queryParam[key] = convertQueryParam(value);
            return queryParam;
        }, {});
    } else {
        return queryParam;
    }
}

export interface ICollegeClient {
    getAllColleges(): Observable<CollegeDto[]>;
    addCollege(dto: NameOnlyUpsertDto): Observable<SimpleUpsertDto>;
    updateCollege(dto: NameOnlyUpsertDto): Observable<SimpleUpsertDto>;
    getCollege(collegeId: string): Observable<CollegeDto>;
}

@Injectable({
    providedIn: 'root'
})
export class CollegeClient implements ICollegeClient {
    constructor(private readonly httpClient: HttpClient) {
    }

    getAllColleges(): Observable<CollegeDto[]> {
        const url = `${Constants.apiAutoGeneratedRoot}/api/College`;

        return this.httpClient.get<any>(url, {  })
            .pipe(map(result => result.map(CollegeDto.fromJS)))
    }

    addCollege(dto: NameOnlyUpsertDto): Observable<SimpleUpsertDto> {
        const url = `${Constants.apiAutoGeneratedRoot}/api/College`;

        return this.httpClient.post<any>(url, dto, {  })
            .pipe(map(SimpleUpsertDto.fromJS))
    }

    updateCollege(dto: NameOnlyUpsertDto): Observable<SimpleUpsertDto> {
        const url = `${Constants.apiAutoGeneratedRoot}/api/College`;

        return this.httpClient.put<any>(url, dto, {  })
            .pipe(map(SimpleUpsertDto.fromJS))
    }

    getCollege(collegeId: string): Observable<CollegeDto> {
        const url = `${Constants.apiAutoGeneratedRoot}/api/College/${collegeId}`;

        return this.httpClient.get<any>(url, {  })
            .pipe(map(CollegeDto.fromJS))
    }
}

export interface ISpeachClient {
    getSpeach(sentence?: string): Observable<Blob | null>;
}

@Injectable({
    providedIn: 'root'
})
export class SpeachClient implements ISpeachClient {
    constructor(private readonly httpClient: HttpClient) {
    }

    getSpeach(sentence?: string): Observable<Blob | null> {
        const queryString = buildQueryString({
            sentence,
        });
        const url = `${Constants.apiAutoGeneratedRoot}/api/Speach${queryString}`;

        return this.httpClient.get(url, { responseType: "blob" });
    }
}

export interface ITestClient {
    getSomethigs(test?: string): Observable<IdDto>;
}

@Injectable({
    providedIn: 'root'
})
export class TestClient implements ITestClient {
    constructor(private readonly httpClient: HttpClient) {
    }

    getSomethigs(test?: string): Observable<IdDto> {
        const queryString = buildQueryString({
            test,
        });
        const url = `${Constants.apiAutoGeneratedRoot}/api/Test${queryString}`;

        return this.httpClient.get<any>(url, {  })
            .pipe(map(IdDto.fromJS))
    }
}

export interface IUserClient {
    getCurrentUserClaims(): Observable<CurrentUsersClaimsDto>;
    addUser(dto: AddUserDto): Observable<SimpleUpsertDto>;
}

@Injectable({
    providedIn: 'root'
})
export class UserClient implements IUserClient {
    constructor(private readonly httpClient: HttpClient) {
    }

    getCurrentUserClaims(): Observable<CurrentUsersClaimsDto> {
        const url = `${Constants.apiAutoGeneratedRoot}/api/User/get-current-user-claims`;

        return this.httpClient.get<any>(url, {  })
            .pipe(map(CurrentUsersClaimsDto.fromJS))
    }

    addUser(dto: AddUserDto): Observable<SimpleUpsertDto> {
        const url = `${Constants.apiAutoGeneratedRoot}/api/User`;

        return this.httpClient.post<any>(url, dto, {  })
            .pipe(map(SimpleUpsertDto.fromJS))
    }
}

export class BaseDto implements IBaseDto {
    id!: string;

    constructor(data?: IBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new BaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): BaseDto {
        const json = this.toJSON();
        let result = new BaseDto();
        result.init(json);
        return result;
    }
}

export interface IBaseDto {
    id: string;
}

export class BaseDtoDateStamps extends BaseDto implements IBaseDtoDateStamps {
    createdAt!: moment.Moment;
    updatedAt?: moment.Moment | undefined;

    constructor(data?: IBaseDtoDateStamps) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? moment(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BaseDtoDateStamps {
        data = typeof data === 'object' ? data : {};
        let result = new BaseDtoDateStamps();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        super.toJSON(data);
        return data; 
    }

    clone(): BaseDtoDateStamps {
        const json = this.toJSON();
        let result = new BaseDtoDateStamps();
        result.init(json);
        return result;
    }
}

export interface IBaseDtoDateStamps extends IBaseDto {
    createdAt: moment.Moment;
    updatedAt?: moment.Moment | undefined;
}

export class BaseDtoVersion extends BaseDtoDateStamps implements IBaseDtoVersion {
    rowVersion?: string | undefined;

    constructor(data?: IBaseDtoVersion) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.rowVersion = _data["rowVersion"];
        }
    }

    static fromJS(data: any): BaseDtoVersion {
        data = typeof data === 'object' ? data : {};
        let result = new BaseDtoVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowVersion"] = this.rowVersion;
        super.toJSON(data);
        return data; 
    }

    clone(): BaseDtoVersion {
        const json = this.toJSON();
        let result = new BaseDtoVersion();
        result.init(json);
        return result;
    }
}

export interface IBaseDtoVersion extends IBaseDtoDateStamps {
    rowVersion?: string | undefined;
}

export class BaseDtoFull extends BaseDtoVersion implements IBaseDtoFull {
    createdByAppUserId!: string;
    updatedByAppUserId?: string | undefined;

    constructor(data?: IBaseDtoFull) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.createdByAppUserId = _data["createdByAppUserId"];
            this.updatedByAppUserId = _data["updatedByAppUserId"];
        }
    }

    static fromJS(data: any): BaseDtoFull {
        data = typeof data === 'object' ? data : {};
        let result = new BaseDtoFull();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdByAppUserId"] = this.createdByAppUserId;
        data["updatedByAppUserId"] = this.updatedByAppUserId;
        super.toJSON(data);
        return data; 
    }

    clone(): BaseDtoFull {
        const json = this.toJSON();
        let result = new BaseDtoFull();
        result.init(json);
        return result;
    }
}

export interface IBaseDtoFull extends IBaseDtoVersion {
    createdByAppUserId: string;
    updatedByAppUserId?: string | undefined;
}

export class CollegeDto extends BaseDtoFull implements ICollegeDto {
    collegeName?: string | undefined;

    constructor(data?: ICollegeDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.collegeName = _data["collegeName"];
        }
    }

    static fromJS(data: any): CollegeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CollegeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collegeName"] = this.collegeName;
        super.toJSON(data);
        return data; 
    }

    clone(): CollegeDto {
        const json = this.toJSON();
        let result = new CollegeDto();
        result.init(json);
        return result;
    }
}

export interface ICollegeDto extends IBaseDtoFull {
    collegeName?: string | undefined;
}

export class SimpleUpsertDto extends BaseDto implements ISimpleUpsertDto {
    rowVersion?: string | undefined;

    constructor(data?: ISimpleUpsertDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.rowVersion = _data["rowVersion"];
        }
    }

    static fromJS(data: any): SimpleUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowVersion"] = this.rowVersion;
        super.toJSON(data);
        return data; 
    }

    clone(): SimpleUpsertDto {
        const json = this.toJSON();
        let result = new SimpleUpsertDto();
        result.init(json);
        return result;
    }
}

export interface ISimpleUpsertDto extends IBaseDto {
    rowVersion?: string | undefined;
}

export class NameOnlyUpsertDto extends BaseDto implements INameOnlyUpsertDto {
    rowVersion?: string | undefined;
    name?: string | undefined;

    constructor(data?: INameOnlyUpsertDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.rowVersion = _data["rowVersion"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): NameOnlyUpsertDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameOnlyUpsertDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowVersion"] = this.rowVersion;
        data["name"] = this.name;
        super.toJSON(data);
        return data; 
    }

    clone(): NameOnlyUpsertDto {
        const json = this.toJSON();
        let result = new NameOnlyUpsertDto();
        result.init(json);
        return result;
    }
}

export interface INameOnlyUpsertDto extends IBaseDto {
    rowVersion?: string | undefined;
    name?: string | undefined;
}

export class IdDto implements IIdDto {
    id!: number;
    rowVersion?: string | undefined;

    constructor(data?: IIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rowVersion = _data["rowVersion"];
        }
    }

    static fromJS(data: any): IdDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rowVersion"] = this.rowVersion;
        return data; 
    }

    clone(): IdDto {
        const json = this.toJSON();
        let result = new IdDto();
        result.init(json);
        return result;
    }
}

export interface IIdDto {
    id: number;
    rowVersion?: string | undefined;
}

export class CurrentUsersClaimsDto implements ICurrentUsersClaimsDto {
    claims?: string[] | undefined;

    constructor(data?: ICurrentUsersClaimsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(item);
            }
        }
    }

    static fromJS(data: any): CurrentUsersClaimsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUsersClaimsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item);
        }
        return data; 
    }

    clone(): CurrentUsersClaimsDto {
        const json = this.toJSON();
        let result = new CurrentUsersClaimsDto();
        result.init(json);
        return result;
    }
}

export interface ICurrentUsersClaimsDto {
    claims?: string[] | undefined;
}

export class AddUserDto implements IAddUserDto {
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roleId!: string;
    collegeIds?: string[] | undefined;

    constructor(data?: IAddUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.roleId = _data["roleId"];
            if (Array.isArray(_data["collegeIds"])) {
                this.collegeIds = [] as any;
                for (let item of _data["collegeIds"])
                    this.collegeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): AddUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["roleId"] = this.roleId;
        if (Array.isArray(this.collegeIds)) {
            data["collegeIds"] = [];
            for (let item of this.collegeIds)
                data["collegeIds"].push(item);
        }
        return data; 
    }

    clone(): AddUserDto {
        const json = this.toJSON();
        let result = new AddUserDto();
        result.init(json);
        return result;
    }
}

export interface IAddUserDto {
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    roleId: string;
    collegeIds?: string[] | undefined;
}